// ! ====================================== APP
// for the spinner to render waiting on all html content to be fully loaded
document.onreadystatechange = function () {
    const body = document.querySelector('body');
    const nav = document.querySelector('nav');
    const sideNav = document.getElementById('sideNav');
    const aboutSection = document.getElementById('aboutSection');
    const specialtiesSection = document.getElementById('specialtiesSection');
    const projSection = document.getElementById('projectSection');
    const contactSection = document.getElementById('contactSection');
    const pageLoader = document.getElementById('portfolioLoader');
    const planetBg = document.querySelector('.planetBg');

    if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        document.getElementById('mobileCanvas').style.display = 'none';
    }

    if (document.readyState !== 'complete') {
        body.style.visibility = 'hidden';
        nav.style.display = 'none';
        sideNav.style.visibility = 'hidden';
        aboutSection.style.visibility = 'hidden';
        specialtiesSection.style.visibility = 'hidden';
        projSection.style.visibility = 'hidden';
        contactSection.style.visibility = 'hidden';
        pageLoader.style.visibility = 'visible';
        planetBg.style.display = 'none';
    } else {
        setTimeout(() => {
            body.style.visibility = 'visible';
            nav.style.display = 'flex';
            sideNav.style.visibility = 'visible';
            aboutSection.style.visibility = 'visible';
            specialtiesSection.style.visibility = 'visible';
            projSection.style.visibility = 'visible';
            contactSection.style.visibility = 'visible';
            pageLoader.style.visibility = 'hidden';
            planetBg.style.display = 'block';
            // ! RENDERING THE NAME
            let nameString = 'jeffrey vanhorn';
            nameString.split('').map(function (char, index) {
                // check if there is a white space char in the string
                if (char.indexOf(' ') >= 0) {
                    $('#headerName').append(`<span class="whiteSpace">${char}</span>`);
                    return;
                }
                $('#headerName').append(`<span class="nameChar" style="animation-delay: ${.5 + index / 6}s;">${char}</span>`);
            });

            // ! RENDERING THE HEADER TEXT
            setTimeout(() => {
                renderHeaderText();
            }, 3000);
        }, 2000);
    }
};

$(window).on("load", function () {
    // resizing the nav to the appropriate specs
    resizeNavHandler();
    window.onscroll = () => {
        //  ! FADE IN EFFECT
        let windowBottom = $(this).scrollTop() + $(this).innerHeight();
        $(".fade").each(function () {
            /* Check the location of each desired element */
            let objectBottom = $(this).offset().top + $(this).outerHeight();
            /* If the element is completely within bounds of the window, fade it in */
            if (objectBottom < windowBottom + 100) {
                //object comes into view (scrolling down)
                if ($(this).css("opacity") == 0) { $(this).fadeTo(500, 1); }
            } else { //object goes out of view (scrolling up)
                if ($(this).css("opacity") == 1) { $(this).fadeTo(500, 0); }
            }
        });
        // ! NAVBAR
        const nav = document.getElementById('nav');
        const scrollBtn = document.getElementById('scrollTopIcon');
        if (this.scrollY <= 100) {
            nav.style.height = '4rem';
            nav.style.backgroundColor = '#000000b0'
            scrollBtn.style.display = 'none';
        }
        else {
            nav.style.height = '3rem';
            nav.style.backgroundColor = 'black';
            scrollBtn.style.display = 'block';
        };
        scrollProgressBar();
    };
    // footer date
    document.getElementById('footerDate').innerHTML = `${new Date().getFullYear()}`;

    // scrollProgressBar();
});
// call this function when the window is resizing
window.onresize = function () {
    // resizing the nav to the appropriate specs
    resizeNavHandler();
}
// render the header text html to the dom
function renderHeaderText() {
    document.getElementById('headerTextRender').innerHTML = `<div id="headerTextWrap">
    <div class="headerTextDash"></div>
    <p id="headerText">full-stack developer</p>
    <div class="headerTextDash"></div>
    </div>`;
};
// smooth scroll function
$('.js-link').click(function (e) {
    e.preventDefault();
    let target = $($(this).attr('href'));
    if (target.length) {
        let scrollTo = target.offset().top - 30;
        $('body, html').animate({ scrollTop: scrollTo + 'px' }, 1500);
    }
});
// navbar on window resize
function resizeNavHandler() {
    let desktopNav = document.getElementById('desktopNav');
    let mobileNav = document.getElementById('mobileNav');
    if (window.innerWidth >= 1025) {
        desktopNav.style.display = 'flex';
        mobileNav.style.display = 'none';
    } else if (window.innerWidth <= 1024) {
        desktopNav.style.display = 'none';
        mobileNav.style.display = 'flex';
    }
};
// toggle the mobile menu button
$('#mobileNavBtn').click(function () {
    $(this).toggleClass('open');
});
// toggle the side nav sliding in
$('#mobileNavBtn').click(function () {
    $('#sideNav').toggleClass('activeNav');
});
// toggle the nav and mobile menu button when clicking on a button inside the side nav
$('.mobileLink').click(function () {
    $('#mobileNavBtn').toggleClass('open');
    $('#sideNav').toggleClass('activeNav');
});

// progress bar handler
const scrollProgressBar = () => {
    let winScroll = document.body.scrollTop || document.documentElement.scrollTop;
    let height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
    let scrolled = (winScroll / height) * 100;
    document.getElementById('progressBar').style.width = scrolled + '%';
};
// ! ========================================================== ABOUT
$(window).on('load', function () {
    // used to make sure the initiate function is only called once
    let hasReached = false;
    $(window).on('scroll', function () {
        let windowBottom = $(this).scrollTop() + $(this).innerHeight();
        $('#personalImg').each(function () {

            /* Check the location of each desired element */
            let objectBottom = $(this).offset().top + $(this).outerHeight();
            // let textTag = document.getElementById('aboutTxt');
            /* If the element is completely within bounds of the window, fade it in */
            if (objectBottom < windowBottom + 100 && !hasReached) {
                let p = document.getElementById('aboutTxt');
                p.innerHTML = '';
                let n = 0;
                let str = `I'm a recent graduate from the University of Texas' coding boot camp. Since graduation I've been a freelance developer working with my own clients and with other small companies on a variety of projects. Additionally, I've been continuing my education through online platforms and extended learning courses. Outside of work, my free time is spent powerlifting, disc golfing, and expanding my knowledge in graphic design.`;
                let typeAbout = setInterval(function () {
                    n = n + 1;
                    p.innerHTML = str.slice(0, n) + ' <span style="color: #c75000; font-size: 1.2rem;">|</span>';
                    if (n === str.length) {
                        clearInterval(typeAbout);
                        p.innerHTML = str;
                        n = 0;
                        setInterval(function () {

                            if (n === 0) {
                                p.innerHTML = str + ' <span style="color: #c75000; font-size: 1.2rem;">|</span>'
                                n = 1;
                            } else {
                                p.innerHTML = str + '<span style="color: transparent; font-size: 1.2rem;">|</span>'
                                n = 0;
                            };
                        }, 500);
                    };
                }, 40)
                hasReached = true;
                // fade in the about image
                document.getElementById('personalImg').style.opacity = 1;
            }
        });
    });
});
// ! ===================== CALLISTO
(function (cjs, an) {

    var p; // shortcut to reference prototypes
    var lib = {}; var ss = {}; var img = {};
    lib.ssMetadata = [];


    (lib.AnMovieClip = function () {
        this.actionFrames = [];
        this.ignorePause = false;
        this.gotoAndPlay = function (positionOrLabel) {
            cjs.MovieClip.prototype.gotoAndPlay.call(this, positionOrLabel);
        }
        this.play = function () {
            cjs.MovieClip.prototype.play.call(this);
        }
        this.gotoAndStop = function (positionOrLabel) {
            cjs.MovieClip.prototype.gotoAndStop.call(this, positionOrLabel);
        }
        this.stop = function () {
            cjs.MovieClip.prototype.stop.call(this);
        }
    }).prototype = p = new cjs.MovieClip();
    // symbols:



    (lib.croppedCallisto = function () {
        this.initialize(img.croppedCallisto);
    }).prototype = p = new cjs.Bitmap();
    p.nominalBounds = new cjs.Rectangle(0, 0, 2400, 720);


    // stage content:
    (lib.savedAnCallisto_HTML5Canvas = function (mode, startPosition, loop, reversed) {
        if (loop == null) { loop = true; }
        if (reversed == null) { reversed = false; }
        var props = new Object();
        props.mode = mode;
        props.startPosition = startPosition;
        props.labels = {};
        props.loop = loop;
        props.reversed = reversed;
        cjs.MovieClip.apply(this, [props]);

        // shadow
        this.shape = new cjs.Shape();
        this.shape.graphics.rf(["rgba(255,255,255,0)", "rgba(0,0,0,0.827)"], [0, 1], -32, -18, 0, -32, -18, 520.4).s().p("Eg46A46UgXlgXkAABghWUgABghVAXlgXlUAXlgXlAhVAABUAhWgABAXlAXlUAXlAXlAAAAhVUAAAAhWgXlAXkUgXlAXmghWAAAUghVAAAgXlgXmg");
        this.shape.setTransform(540.15, 541.15);

        this.timeline.addTween(cjs.Tween.get(this.shape).wait(500));

        // mask_idn (mask)
        var mask = new cjs.Shape();
        mask._off = true;
        mask.graphics.p("Eg46A46UgXlgXkAABghWUgABghVAXlgXlUAXlgXlAhVAABUAhWgABAXlAXlUAXlAXlAAAAhVUAAAAhWgXlAXkUgXlAXmghWAAAUghVAAAgXlgXmg");
        mask.setTransform(540.15, 541.15);

        // Layer_1
        this.instance = new lib.croppedCallisto();
        this.instance.setTransform(35.55, -266.25, 1.5032, 1.5032, 23.0047);

        var maskedShapeInstanceList = [this.instance];

        for (var shapedInstanceItr = 0; shapedInstanceItr < maskedShapeInstanceList.length; shapedInstanceItr++) {
            maskedShapeInstanceList[shapedInstanceItr].mask = mask;
        }

        this.timeline.addTween(cjs.Tween.get(this.instance).to({ rotation: 23.0049, x: -1957.85, y: -1110.65 }, 499).wait(1));

        this._renderFirstFrame();

    }).prototype = p = new lib.AnMovieClip();
    p.nominalBounds = new cjs.Rectangle(565, 566, 490.29999999999995, 490.29999999999995);
    // library properties:
    lib.properties = {
        id: '1502B00D1E71F64390F1196A3331296B',
        width: 1080,
        height: 1080,
        fps: 10,
        color: "#000000",
        opacity: 0.00,
        manifest: [
            { src: "/assets/images/planets/croppedCallisto.jpg", id: "croppedCallisto" }
        ],
        preloads: []
    };



    // bootstrap callback support:

    (lib.Stage = function (canvas) {
        createjs.Stage.call(this, canvas);
    }).prototype = p = new createjs.Stage();

    p.setAutoPlay = function (autoPlay) {
        this.tickEnabled = autoPlay;
    }
    p.play = function () { this.tickEnabled = true; this.getChildAt(0).gotoAndPlay(this.getTimelinePosition()) }
    p.stop = function (ms) { if (ms) this.seek(ms); this.tickEnabled = false; }
    p.seek = function (ms) { this.tickEnabled = true; this.getChildAt(0).gotoAndStop(lib.properties.fps * ms / 1000); }
    p.getDuration = function () { return this.getChildAt(0).totalFrames / lib.properties.fps * 1000; }

    p.getTimelinePosition = function () { return this.getChildAt(0).currentFrame / lib.properties.fps * 1000; }

    an.bootcompsLoaded = an.bootcompsLoaded || [];
    if (!an.bootstrapListeners) {
        an.bootstrapListeners = [];
    }

    an.bootstrapCallback = function (fnCallback) {
        an.bootstrapListeners.push(fnCallback);
        if (an.bootcompsLoaded.length > 0) {
            for (var i = 0; i < an.bootcompsLoaded.length; ++i) {
                fnCallback(an.bootcompsLoaded[i]);
            }
        }
    };

    an.compositions = an.compositions || {};
    an.compositions['1502B00D1E71F64390F1196A3331296B'] = {
        getStage: function () { return exportRoot.stage; },
        getLibrary: function () { return lib; },
        getSpriteSheet: function () { return ss; },
        getImages: function () { return img; }
    };

    an.compositionLoaded = function (id) {
        an.bootcompsLoaded.push(id);
        for (var j = 0; j < an.bootstrapListeners.length; j++) {
            an.bootstrapListeners[j](id);
        }
    }

    an.getComposition = function (id) {
        return an.compositions[id];
    }


    an.makeResponsive = function (isResp, respDim, isScale, scaleType, domContainers) {
        var lastW, lastH, lastS = 1;
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        function resizeCanvas() {
            var w = lib.properties.width, h = lib.properties.height;
            var iw = window.innerWidth, ih = window.innerHeight;
            var pRatio = window.devicePixelRatio || 1, xRatio = iw / w, yRatio = ih / h, sRatio = 1;
            if (isResp) {
                if ((respDim == 'width' && lastW == iw) || (respDim == 'height' && lastH == ih)) {
                    sRatio = lastS;
                }
                else if (!isScale) {
                    if (iw < w || ih < h)
                        sRatio = Math.min(xRatio, yRatio);
                }
                else if (scaleType == 1) {
                    sRatio = Math.min(xRatio, yRatio);
                }
                else if (scaleType == 2) {
                    sRatio = Math.max(xRatio, yRatio);
                }
            }
            domContainers[0].width = w * pRatio * sRatio;
            domContainers[0].height = h * pRatio * sRatio;
            domContainers.forEach(function (container) {
                // container.style.width = w * sRatio + 'px';				
                // container.style.height = h * sRatio + 'px';			
            });
            stage.scaleX = pRatio * sRatio;
            stage.scaleY = pRatio * sRatio;
            lastW = iw; lastH = ih; lastS = sRatio;
            stage.tickOnUpdate = false;
            stage.update();
            stage.tickOnUpdate = true;
        }
    }
    an.handleSoundStreamOnTick = function (event) {
        if (!event.paused) {
            var stageChild = stage.getChildAt(0);
            if (!stageChild.paused || stageChild.ignorePause) {
                stageChild.syncStreamSounds();
            }
        }
    }


})(createjs = createjs || {}, AdobeAn = AdobeAn || {});
var createjs, AdobeAn;

// ! ============================================ CONTACT
$(window).on('load', function () {

    let hasReached = false;
    $(window).on('scroll', function () {
        let windowBottom = $(this).scrollTop() + $(this).innerHeight();
        $('#formTitle').each(function () {
            /* Check the location of each desired element */
            let objectBottom = $(this).offset().top + $(this).outerHeight();
            /* If the element is completely within bounds of the window, fade it in */
            if (objectBottom < windowBottom - 100 && !hasReached) {
                // image.style.display = 'block';
                let p = document.getElementById('formTitle');
                p.innerHTML = '';
                let n = 0;
                let str = 'Send A Message';
                let typeSpecialty = setInterval(function () {
                    n = n + 1;
                    p.innerHTML = str.slice(0, n) + ' <span style="color: #c75000; font-size: 2.2rem;">|</span>';
                    if (n === str.length) {
                        clearInterval(typeSpecialty);
                        p.innerHTML = str;
                        n = 0;
                        setInterval(function () {

                            if (n === 0) {
                                p.innerHTML = str + '<span style="color: #c75000; font-size: 2.2rem;">|</span>'
                                n = 1;
                            } else {
                                p.innerHTML = str + '<span style="color: transparent; font-size: 2.2rem;">|</span>'
                                n = 0;
                            };
                        }, 500);
                    };
                }, 40)
                hasReached = true;
            }
        });
    });
    // adding these to keep bots away
    let email1 = 'jeffrey.';
    let email2 = 'vanhorn';
    let email3 = '@yahoo.com';

    $('.locationEmail').attr('href', `mailto:${email1}${email2}${email3}`);
    document.getElementById('mapImg').style.display = 'block';
    document.getElementById('map').style.display = 'none';
    // if there is not a mobile device being used render the tom tom map. else render an image
    if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        // map styles and initiation
        // let map = tt.map({
        //     key: 'idwJh8J0x9cq7vGdT0SgaIkuv0Gdb1pM',
        //     container: 'map',
        //     basePath: '/',
        //     style: '/custommap.json',
        //     source: 'vector',
        //     center: [-97, 29],
        //     zoom: 4
        // });

        // // adding a marker to the tom tom map
        // function createMarker(position, color) {
        //     let markerElement = document.createElement('div');
        //     markerElement.className = 'marker';

        //     let markerContentElement = document.createElement('div');
        //     markerContentElement.className = 'marker-content';
        //     markerContentElement.style.backgroundColor = color;
        //     markerElement.appendChild(markerContentElement);

        //     // add marker to map
        //     new tt.Marker({ scale: 1.3 })
        //         .setLngLat(position)
        //         .addTo(map);
        // };

        // createMarker([-95.461195, 30.168032], '#3b4e74', 'The Woodlands, TX');
    } else {
        // display the map image and remove the map api
        document.getElementById('mapImg').style.display = 'block';
        document.getElementById('map').style.display = 'none';
    }
});

// on form submit
document.getElementById('submitFormBtn').onclick = (e) => {
    let name = $('#nameInput').val();
    let email = $('#emailInput').val().trim().toLowerCase();
    let message = $('#messageInput').val();

    if (!name && !email && !message) {
        openErrModal('Please fill out each input');
        return;
    }

    if (!name) {
        openErrModal('Please add a name');
        return;
    }
    const emailRegex = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    if (!email || !emailRegex.test(email)) {
        openErrModal('Please enter a valid email');
        return;
    }
    if (!message) {
        openErrModal('Please enter a message');
        return;
    }
    openRobotModal();
};

// ! ANTI-ROBOT MODAL
const openRobotModal = () => {
    document.getElementById('robotModalOverlay').classList.add('is-robot-modal-visible');
    document.getElementById('robotModal').classList.add('is-robot-modal-visible');
};
// the x button inside the robot modal to close it
document.getElementById('robotModalCloseBtn').addEventListener('click', function () {
    document.getElementById('robotModalOverlay').classList.remove('is-robot-modal-visible');
    document.getElementById('robotModal').classList.remove('is-robot-modal-visible');
});
// for if the user clicks anywhere outside the  robot modal modal it will close the modal
document.getElementById('robotModalOverlay').addEventListener('click', function () {
    document.getElementById('robotModalOverlay').classList.remove('is-robot-modal-visible');
    document.getElementById('robotModal').classList.remove('is-robot-modal-visible');
});

// ! ERR MODAL
const openErrModal = (msg) => {
    document.getElementById('errOverlay').classList.add('is-visible');
    document.getElementById('errModal').classList.add('is-visible');
    document.getElementById('modalMessage').innerHTML = msg;
};

// the x button inside the modal to close it
document.getElementById('close-btn').addEventListener('click', function () {
    document.getElementById('errOverlay').classList.remove('is-visible');
    document.getElementById('errModal').classList.remove('is-visible');
});
// for if the user clicks anywhere outside the modal it will close the modal
document.getElementById('errOverlay').addEventListener('click', function () {
    document.getElementById('errOverlay').classList.remove('is-visible');
    document.getElementById('errModal').classList.remove('is-visible');
});
// ! ============================================================== JUPITER
(function (cjs, an) {

    var p; // shortcut to reference prototypes
    var lib = {}; var ss = {}; var img = {};
    lib.ssMetadata = [];


    (lib.AnMovieClip = function () {
        this.actionFrames = [];
        this.ignorePause = false;
        this.gotoAndPlay = function (positionOrLabel) {
            cjs.MovieClip.prototype.gotoAndPlay.call(this, positionOrLabel);
        }
        this.play = function () {
            cjs.MovieClip.prototype.play.call(this);
        }
        this.gotoAndStop = function (positionOrLabel) {
            cjs.MovieClip.prototype.gotoAndStop.call(this, positionOrLabel);
        }
        this.stop = function () {
            cjs.MovieClip.prototype.stop.call(this);
        }
    }).prototype = p = new cjs.MovieClip();
    // symbols:



    (lib.jupiter1 = function () {
        this.initialize(img.jupiter1);
    }).prototype = p = new cjs.Bitmap();
    p.nominalBounds = new cjs.Rectangle(0, 0, 2310, 1024);


    (lib.fullMap = function (mode, startPosition, loop, reversed) {
        if (loop == null) { loop = true; }
        if (reversed == null) { reversed = false; }
        var props = new Object();
        props.mode = mode;
        props.startPosition = startPosition;
        props.labels = {};
        props.loop = loop;
        props.reversed = reversed;
        cjs.MovieClip.apply(this, [props]);

        // Layer_1
        this.instance = new lib.jupiter1();
        this.instance.setTransform(2388.5, 0, 1.0346, 1.0346);

        this.instance_1 = new lib.jupiter1();
        this.instance_1.setTransform(0, 0.15, 1.0346, 1.0346);

        this.timeline.addTween(cjs.Tween.get({}).to({ state: [{ t: this.instance_1 }, { t: this.instance }] }).wait(1));

        this._renderFirstFrame();

    }).prototype = p = new cjs.MovieClip();
    p.nominalBounds = new cjs.Rectangle(0, 0, 4778.5, 1059.6);


    // stage content:
    (lib.savedAnJupiter_HTML5Canvas = function (mode, startPosition, loop, reversed) {
        if (loop == null) { loop = true; }
        if (reversed == null) { reversed = false; }
        var props = new Object();
        props.mode = mode;
        props.startPosition = startPosition;
        props.labels = {};
        props.loop = loop;
        props.reversed = reversed;
        cjs.MovieClip.apply(this, [props]);

        // shadow
        this.shape = new cjs.Shape();
        this.shape.graphics.rf(["rgba(255,255,255,0)", "rgba(0,0,0,0.827)"], [0, 1], -40, -22.9, 0, -40, -22.9, 520.4).s().p("Eg46A46UgXlgXkAABghWUgABghVAXlgXlUAXlgXlAhVAABUAhWgABAXlAXlUAXlAXlAAAAhVUAAAAhWgXlAXkUgXlAXmghWAAAUghVAAAgXlgXmg");
        this.shape.setTransform(540.15, 541.15);

        this.timeline.addTween(cjs.Tween.get(this.shape).wait(500));

        // mask_idn (mask)
        var mask = new cjs.Shape();
        mask._off = true;
        mask.graphics.p("Eg46A46UgXlgXkAABghWUgABghVAXlgXlUAXlgXlAhVAABUAhWgABAXlAXlUAXlAXlAAAAhVUAAAAhWgXlAXkUgXlAXmghWAAAUghVAAAgXlgXmg");
        mask.setTransform(540.15, 541.15);

        // Layer_1
        this.instance = new lib.fullMap("synched", 0);
        this.instance.setTransform(2337.75, 821.25, 1, 1, 8.9504, 0, 0, 2389.2, 529.8);

        var maskedShapeInstanceList = [this.instance];

        for (var shapedInstanceItr = 0; shapedInstanceItr < maskedShapeInstanceList.length; shapedInstanceItr++) {
            maskedShapeInstanceList[shapedInstanceItr].mask = mask;
        }

        this.timeline.addTween(cjs.Tween.get(this.instance).to({ x: -22.8, y: 451.15 }, 499).wait(1));

        this._renderFirstFrame();

    }).prototype = p = new lib.AnMovieClip();
    p.nominalBounds = new cjs.Rectangle(565, 566, 490.29999999999995, 490.29999999999995);
    // library properties:
    lib.properties = {
        id: '41345EC838562E4499D52D822F835ECC',
        width: 1080,
        height: 1080,
        fps: 10,
        color: "#000000",
        opacity: 0.00,
        manifest: [
            { src: "/assets/images/planets/jupiter1.jpg", id: "jupiter1" }
        ],
        preloads: []
    };



    // bootstrap callback support:

    (lib.Stage = function (canvas) {
        createjs.Stage.call(this, canvas);
    }).prototype = p = new createjs.Stage();

    p.setAutoPlay = function (autoPlay) {
        this.tickEnabled = autoPlay;
    }
    p.play = function () { this.tickEnabled = true; this.getChildAt(0).gotoAndPlay(this.getTimelinePosition()) }
    p.stop = function (ms) { if (ms) this.seek(ms); this.tickEnabled = false; }
    p.seek = function (ms) { this.tickEnabled = true; this.getChildAt(0).gotoAndStop(lib.properties.fps * ms / 1000); }
    p.getDuration = function () { return this.getChildAt(0).totalFrames / lib.properties.fps * 1000; }

    p.getTimelinePosition = function () { return this.getChildAt(0).currentFrame / lib.properties.fps * 1000; }

    an.bootcompsLoaded = an.bootcompsLoaded || [];
    if (!an.bootstrapListeners) {
        an.bootstrapListeners = [];
    }

    an.bootstrapCallback = function (fnCallback) {
        an.bootstrapListeners.push(fnCallback);
        if (an.bootcompsLoaded.length > 0) {
            for (var i = 0; i < an.bootcompsLoaded.length; ++i) {
                fnCallback(an.bootcompsLoaded[i]);
            }
        }
    };

    an.compositions = an.compositions || {};
    an.compositions['41345EC838562E4499D52D822F835ECC'] = {
        getStage: function () { return exportRoot.stage; },
        getLibrary: function () { return lib; },
        getSpriteSheet: function () { return ss; },
        getImages: function () { return img; }
    };

    an.compositionLoaded = function (id) {
        an.bootcompsLoaded.push(id);
        for (var j = 0; j < an.bootstrapListeners.length; j++) {
            an.bootstrapListeners[j](id);
        }
    }

    an.getComposition = function (id) {
        return an.compositions[id];
    }


    an.makeResponsive = function (isResp, respDim, isScale, scaleType, domContainers) {
        var lastW, lastH, lastS = 1;
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        function resizeCanvas() {
            var w = lib.properties.width, h = lib.properties.height;
            var iw = window.innerWidth, ih = window.innerHeight;
            var pRatio = window.devicePixelRatio || 1, xRatio = iw / w, yRatio = ih / h, sRatio = 1;
            if (isResp) {
                if ((respDim == 'width' && lastW == iw) || (respDim == 'height' && lastH == ih)) {
                    sRatio = lastS;
                }
                else if (!isScale) {
                    if (iw < w || ih < h)
                        sRatio = Math.min(xRatio, yRatio);
                }
                else if (scaleType == 1) {
                    sRatio = Math.min(xRatio, yRatio);
                }
                else if (scaleType == 2) {
                    sRatio = Math.max(xRatio, yRatio);
                }
            }
            domContainers[0].width = w * pRatio * sRatio;
            domContainers[0].height = h * pRatio * sRatio;
            domContainers.forEach(function (container) {
                // container.style.width = w * sRatio + 'px';				
                // container.style.height = h * sRatio + 'px';			
            });
            stage.scaleX = pRatio * sRatio;
            stage.scaleY = pRatio * sRatio;
            lastW = iw; lastH = ih; lastS = sRatio;
            stage.tickOnUpdate = false;
            stage.update();
            stage.tickOnUpdate = true;
        }
    }
    an.handleSoundStreamOnTick = function (event) {
        if (!event.paused) {
            var stageChild = stage.getChildAt(0);
            if (!stageChild.paused || stageChild.ignorePause) {
                stageChild.syncStreamSounds();
            }
        }
    }


})(createjs = createjs || {}, AdobeAn = AdobeAn || {});
var createjs, AdobeAn;
// ! ================================================ MARS
(function (cjs, an) {

    var p; // shortcut to reference prototypes
    var lib = {}; var ss = {}; var img = {};
    lib.ssMetadata = [];


    (lib.AnMovieClip = function () {
        this.actionFrames = [];
        this.ignorePause = false;
        this.gotoAndPlay = function (positionOrLabel) {
            cjs.MovieClip.prototype.gotoAndPlay.call(this, positionOrLabel);
        }
        this.play = function () {
            cjs.MovieClip.prototype.play.call(this);
        }
        this.gotoAndStop = function (positionOrLabel) {
            cjs.MovieClip.prototype.gotoAndStop.call(this, positionOrLabel);
        }
        this.stop = function () {
            cjs.MovieClip.prototype.stop.call(this);
        }
    }).prototype = p = new cjs.MovieClip();
    // symbols:



    (lib.croppedMars = function () {
        this.initialize(img.croppedMars);
    }).prototype = p = new cjs.Bitmap();
    p.nominalBounds = new cjs.Rectangle(0, 0, 2400, 720);


    // stage content:
    (lib.savedAnMars_HTML5Canvas = function (mode, startPosition, loop, reversed) {
        if (loop == null) { loop = true; }
        if (reversed == null) { reversed = false; }
        var props = new Object();
        props.mode = mode;
        props.startPosition = startPosition;
        props.labels = {};
        props.loop = loop;
        props.reversed = reversed;
        cjs.MovieClip.apply(this, [props]);

        // shadow
        this.shape = new cjs.Shape();
        this.shape.graphics.rf(["rgba(255,255,255,0)", "rgba(0,0,0,0.827)"], [0, 1], -32, -24, 0, -32, -24, 520.4).s().p("Eg46A46UgXlgXkAAAghWUAAAghVAXlgXlUAXlgXlAhVAAAUAhWAAAAXkAXlUAXmAXlAAAAhVUAAAAhWgXmAXkUgXkAXmghWAAAUghVAAAgXlgXmg");
        this.shape.setTransform(540, 540);

        this.timeline.addTween(cjs.Tween.get(this.shape).wait(500));

        // mask_idn (mask)
        var mask = new cjs.Shape();
        mask._off = true;
        mask.graphics.p("Eg46A46UgXlgXkAAAghWUAAAghVAXlgXlUAXlgXlAhVAAAUAhWAAAAXkAXlUAXmAXlAAAAhVUAAAAhWgXmAXkUgXkAXmghWAAAUghVAAAgXlgXmg");
        mask.setTransform(540, 540);

        // Layer_1
        this.instance = new lib.croppedMars();
        this.instance.setTransform(127.25, -110.6, 1.4914, 1.4914, 13.6969);

        var maskedShapeInstanceList = [this.instance];

        for (var shapedInstanceItr = 0; shapedInstanceItr < maskedShapeInstanceList.length; shapedInstanceItr++) {
            maskedShapeInstanceList[shapedInstanceItr].mask = mask;
        }

        this.timeline.addTween(cjs.Tween.get(this.instance).to({ x: -1956.5, y: -617.65 }, 499).wait(1));

        this._renderFirstFrame();

    }).prototype = p = new lib.AnMovieClip();
    p.nominalBounds = new cjs.Rectangle(564.9, 564.9, 490.30000000000007, 490.30000000000007);
    // library properties:
    lib.properties = {
        id: 'D7E3423B551E00458CD72DB4C211F4E1',
        width: 1080,
        height: 1080,
        fps: 10,
        color: "#000000",
        opacity: 0.00,
        manifest: [
            { src: "/assets/images/planets/croppedMars.jpg", id: "croppedMars" }
        ],
        preloads: []
    };



    // bootstrap callback support:

    (lib.Stage = function (canvas) {
        createjs.Stage.call(this, canvas);
    }).prototype = p = new createjs.Stage();

    p.setAutoPlay = function (autoPlay) {
        this.tickEnabled = autoPlay;
    }
    p.play = function () { this.tickEnabled = true; this.getChildAt(0).gotoAndPlay(this.getTimelinePosition()) }
    p.stop = function (ms) { if (ms) this.seek(ms); this.tickEnabled = false; }
    p.seek = function (ms) { this.tickEnabled = true; this.getChildAt(0).gotoAndStop(lib.properties.fps * ms / 1000); }
    p.getDuration = function () { return this.getChildAt(0).totalFrames / lib.properties.fps * 1000; }

    p.getTimelinePosition = function () { return this.getChildAt(0).currentFrame / lib.properties.fps * 1000; }

    an.bootcompsLoaded = an.bootcompsLoaded || [];
    if (!an.bootstrapListeners) {
        an.bootstrapListeners = [];
    }

    an.bootstrapCallback = function (fnCallback) {
        an.bootstrapListeners.push(fnCallback);
        if (an.bootcompsLoaded.length > 0) {
            for (var i = 0; i < an.bootcompsLoaded.length; ++i) {
                fnCallback(an.bootcompsLoaded[i]);
            }
        }
    };

    an.compositions = an.compositions || {};
    an.compositions['D7E3423B551E00458CD72DB4C211F4E1'] = {
        getStage: function () { return exportRoot.stage; },
        getLibrary: function () { return lib; },
        getSpriteSheet: function () { return ss; },
        getImages: function () { return img; }
    };

    an.compositionLoaded = function (id) {
        an.bootcompsLoaded.push(id);
        for (var j = 0; j < an.bootstrapListeners.length; j++) {
            an.bootstrapListeners[j](id);
        }
    }

    an.getComposition = function (id) {
        return an.compositions[id];
    }


    an.makeResponsive = function (isResp, respDim, isScale, scaleType, domContainers) {
        var lastW, lastH, lastS = 1;
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        function resizeCanvas() {
            var w = lib.properties.width, h = lib.properties.height;
            var iw = window.innerWidth, ih = window.innerHeight;
            var pRatio = window.devicePixelRatio || 1, xRatio = iw / w, yRatio = ih / h, sRatio = 1;
            if (isResp) {
                if ((respDim == 'width' && lastW == iw) || (respDim == 'height' && lastH == ih)) {
                    sRatio = lastS;
                }
                else if (!isScale) {
                    if (iw < w || ih < h)
                        sRatio = Math.min(xRatio, yRatio);
                }
                else if (scaleType == 1) {
                    sRatio = Math.min(xRatio, yRatio);
                }
                else if (scaleType == 2) {
                    sRatio = Math.max(xRatio, yRatio);
                }
            }
            domContainers[0].width = w * pRatio * sRatio;
            domContainers[0].height = h * pRatio * sRatio;
            domContainers.forEach(function (container) {
                // container.style.width = w * sRatio + 'px';				
                // container.style.height = h * sRatio + 'px';			
            });
            stage.scaleX = pRatio * sRatio;
            stage.scaleY = pRatio * sRatio;
            lastW = iw; lastH = ih; lastS = sRatio;
            stage.tickOnUpdate = false;
            stage.update();
            stage.tickOnUpdate = true;
        }
    }
    an.handleSoundStreamOnTick = function (event) {
        if (!event.paused) {
            var stageChild = stage.getChildAt(0);
            if (!stageChild.paused || stageChild.ignorePause) {
                stageChild.syncStreamSounds();
            }
        }
    }


})(createjs = createjs || {}, AdobeAn = AdobeAn || {});
var createjs, AdobeAn;
// ! ================================== MOON
(function (cjs, an) {

    var p; // shortcut to reference prototypes
    var lib = {}; var ss = {}; var img = {};
    lib.ssMetadata = [];


    (lib.AnMovieClip = function () {
        this.actionFrames = [];
        this.ignorePause = false;
        this.gotoAndPlay = function (positionOrLabel) {
            cjs.MovieClip.prototype.gotoAndPlay.call(this, positionOrLabel);
        }
        this.play = function () {
            cjs.MovieClip.prototype.play.call(this);
        }
        this.gotoAndStop = function (positionOrLabel) {
            cjs.MovieClip.prototype.gotoAndStop.call(this, positionOrLabel);
        }
        this.stop = function () {
            cjs.MovieClip.prototype.stop.call(this);
        }
    }).prototype = p = new cjs.MovieClip();
    // symbols:



    (lib.croppedMoon = function () {
        this.initialize(img.croppedMoon);
    }).prototype = p = new cjs.Bitmap();
    p.nominalBounds = new cjs.Rectangle(0, 0, 2400, 720);


    // stage content:
    (lib.savedAnMoon_HTML5Canvas = function (mode, startPosition, loop, reversed) {
        if (loop == null) { loop = true; }
        if (reversed == null) { reversed = false; }
        var props = new Object();
        props.mode = mode;
        props.startPosition = startPosition;
        props.labels = {};
        props.loop = loop;
        props.reversed = reversed;
        cjs.MovieClip.apply(this, [props]);

        // shadow
        this.shape = new cjs.Shape();
        this.shape.graphics.rf(["rgba(255,255,255,0)", "rgba(0,0,0,0.827)"], [0, 1], -40, -32, 0, -40, -32, 520.4).s().p("Eg46A46UgXlgXkAABghWUgABghVAXlgXlUAXlgXlAhVAAAUAhWAAAAXlAXlUAXlAXlAAAAhVUAAAAhWgXlAXkUgXlAXmghWAAAUghVAAAgXlgXmg");
        this.shape.setTransform(540.15, 542.15);

        this.timeline.addTween(cjs.Tween.get(this.shape).wait(500));

        // mask_idn (mask)
        var mask = new cjs.Shape();
        mask._off = true;
        mask.graphics.p("Eg46A46UgXlgXkAABghWUgABghVAXlgXlUAXlgXlAhVAAAUAhWAAAAXlAXlUAXlAXlAAAAhVUAAAAhWgXlAXkUgXlAXmghWAAAUghVAAAgXlgXmg");
        mask.setTransform(540.15, 542.15);

        // Layer_1
        this.instance = new lib.croppedMoon();
        this.instance.setTransform(104.2, -137.1, 1.4958, 1.4958, 15.9624);

        var maskedShapeInstanceList = [this.instance];

        for (var shapedInstanceItr = 0; shapedInstanceItr < maskedShapeInstanceList.length; shapedInstanceItr++) {
            maskedShapeInstanceList[shapedInstanceItr].mask = mask;
        }

        this.timeline.addTween(cjs.Tween.get(this.instance).to({ x: -1963.6, y: -730.35 }, 499).wait(1));

        this._renderFirstFrame();

    }).prototype = p = new lib.AnMovieClip();
    p.nominalBounds = new cjs.Rectangle(565, 567, 490.29999999999995, 490.29999999999995);
    // library properties:
    lib.properties = {
        id: 'A3AB6E8092563F44A2D2FE775D5778E1',
        width: 1080,
        height: 1080,
        fps: 10,
        color: "#000000",
        opacity: 0.00,
        manifest: [
            { src: "/assets/images/planets/croppedMoon.jpg", id: "croppedMoon" }
        ],
        preloads: []
    };



    // bootstrap callback support:

    (lib.Stage = function (canvas) {
        createjs.Stage.call(this, canvas);
    }).prototype = p = new createjs.Stage();

    p.setAutoPlay = function (autoPlay) {
        this.tickEnabled = autoPlay;
    }
    p.play = function () { this.tickEnabled = true; this.getChildAt(0).gotoAndPlay(this.getTimelinePosition()) }
    p.stop = function (ms) { if (ms) this.seek(ms); this.tickEnabled = false; }
    p.seek = function (ms) { this.tickEnabled = true; this.getChildAt(0).gotoAndStop(lib.properties.fps * ms / 1000); }
    p.getDuration = function () { return this.getChildAt(0).totalFrames / lib.properties.fps * 1000; }

    p.getTimelinePosition = function () { return this.getChildAt(0).currentFrame / lib.properties.fps * 1000; }

    an.bootcompsLoaded = an.bootcompsLoaded || [];
    if (!an.bootstrapListeners) {
        an.bootstrapListeners = [];
    }

    an.bootstrapCallback = function (fnCallback) {
        an.bootstrapListeners.push(fnCallback);
        if (an.bootcompsLoaded.length > 0) {
            for (var i = 0; i < an.bootcompsLoaded.length; ++i) {
                fnCallback(an.bootcompsLoaded[i]);
            }
        }
    };

    an.compositions = an.compositions || {};
    an.compositions['A3AB6E8092563F44A2D2FE775D5778E1'] = {
        getStage: function () { return exportRoot.stage; },
        getLibrary: function () { return lib; },
        getSpriteSheet: function () { return ss; },
        getImages: function () { return img; }
    };

    an.compositionLoaded = function (id) {
        an.bootcompsLoaded.push(id);
        for (var j = 0; j < an.bootstrapListeners.length; j++) {
            an.bootstrapListeners[j](id);
        }
    }

    an.getComposition = function (id) {
        return an.compositions[id];
    }


    an.makeResponsive = function (isResp, respDim, isScale, scaleType, domContainers) {
        var lastW, lastH, lastS = 1;
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        function resizeCanvas() {
            var w = lib.properties.width, h = lib.properties.height;
            var iw = window.innerWidth, ih = window.innerHeight;
            var pRatio = window.devicePixelRatio || 1, xRatio = iw / w, yRatio = ih / h, sRatio = 1;
            if (isResp) {
                if ((respDim == 'width' && lastW == iw) || (respDim == 'height' && lastH == ih)) {
                    sRatio = lastS;
                }
                else if (!isScale) {
                    if (iw < w || ih < h)
                        sRatio = Math.min(xRatio, yRatio);
                }
                else if (scaleType == 1) {
                    sRatio = Math.min(xRatio, yRatio);
                }
                else if (scaleType == 2) {
                    sRatio = Math.max(xRatio, yRatio);
                }
            }
            domContainers[0].width = w * pRatio * sRatio;
            domContainers[0].height = h * pRatio * sRatio;
            domContainers.forEach(function (container) {
                // container.style.width = w * sRatio + 'px';				
                // container.style.height = h * sRatio + 'px';			
            });
            stage.scaleX = pRatio * sRatio;
            stage.scaleY = pRatio * sRatio;
            lastW = iw; lastH = ih; lastS = sRatio;
            stage.tickOnUpdate = false;
            stage.update();
            stage.tickOnUpdate = true;
        }
    }
    an.handleSoundStreamOnTick = function (event) {
        if (!event.paused) {
            var stageChild = stage.getChildAt(0);
            if (!stageChild.paused || stageChild.ignorePause) {
                stageChild.syncStreamSounds();
            }
        }
    }


})(createjs = createjs || {}, AdobeAn = AdobeAn || {});
var createjs, AdobeAn;
// ! ================================ NEPTUNE
(function (cjs, an) {

    var p; // shortcut to reference prototypes
    var lib = {}; var ss = {}; var img = {};
    lib.ssMetadata = [
        { name: "neptune_atlas_1", frames: [[0, 0, 1440, 720]] }
    ];


    (lib.AnMovieClip = function () {
        this.actionFrames = [];
        this.ignorePause = false;
        this.gotoAndPlay = function (positionOrLabel) {
            cjs.MovieClip.prototype.gotoAndPlay.call(this, positionOrLabel);
        }
        this.play = function () {
            cjs.MovieClip.prototype.play.call(this);
        }
        this.gotoAndStop = function (positionOrLabel) {
            cjs.MovieClip.prototype.gotoAndStop.call(this, positionOrLabel);
        }
        this.stop = function () {
            cjs.MovieClip.prototype.stop.call(this);
        }
    }).prototype = p = new cjs.MovieClip();
    // symbols:



    (lib.neptune = function () {
        this.initialize(ss["neptune_atlas_1"]);
        this.gotoAndStop(0);
    }).prototype = p = new cjs.Sprite();



    (lib.fullMap = function (mode, startPosition, loop, reversed) {
        if (loop == null) { loop = true; }
        if (reversed == null) { reversed = false; }
        var props = new Object();
        props.mode = mode;
        props.startPosition = startPosition;
        props.labels = {};
        props.loop = loop;
        props.reversed = reversed;
        cjs.MovieClip.apply(this, [props]);

        // Layer_1
        this.instance = new lib.neptune();
        this.instance.setTransform(2127.5, 0, 1.4778, 1.4778);

        this.instance_1 = new lib.neptune();
        this.instance_1.setTransform(0, 0, 1.4778, 1.4778);

        this.timeline.addTween(cjs.Tween.get({}).to({ state: [{ t: this.instance_1 }, { t: this.instance }] }).wait(1));

        this._renderFirstFrame();

    }).prototype = p = new cjs.MovieClip();
    p.nominalBounds = new cjs.Rectangle(0, 0, 4255.6, 1064.1);


    // stage content:
    (lib.savedAnNeptune_HTML5Canvas = function (mode, startPosition, loop, reversed) {
        if (loop == null) { loop = true; }
        if (reversed == null) { reversed = false; }
        var props = new Object();
        props.mode = mode;
        props.startPosition = startPosition;
        props.labels = {};
        props.loop = loop;
        props.reversed = reversed;
        cjs.MovieClip.apply(this, [props]);

        // shadow
        this.shape = new cjs.Shape();
        this.shape.graphics.rf(["rgba(255,255,255,0)", "rgba(0,0,0,0.827)"], [0, 1], -46, -34, 0, -46, -34, 520.4).s().p("Eg46A46UgXlgXkAABghWUgABghVAXlgXlUAXlgXlAhVAAAUAhWAAAAXlAXlUAXlAXlAAAAhVUAAAAhWgXlAXkUgXlAXmghWAAAUghVAAAgXlgXmg");
        this.shape.setTransform(540.15, 542.15);

        this.timeline.addTween(cjs.Tween.get(this.shape).wait(500));

        // mask_idn (mask)
        var mask = new cjs.Shape();
        mask._off = true;
        mask.graphics.p("Eg46A46UgXlgXkAABghWUgABghVAXlgXlUAXlgXlAhVAAAUAhWAAAAXlAXlUAXlAXlAAAAhVUAAAAhWgXlAXkUgXlAXmghWAAAUghVAAAgXlgXmg");
        mask.setTransform(540.15, 542.15);

        // Layer_1
        this.instance = new lib.fullMap("synched", 0);
        this.instance.setTransform(1901.85, 756.2, 1, 1, 8.9779, 0, 0, 2127.8, 532);

        var maskedShapeInstanceList = [this.instance];

        for (var shapedInstanceItr = 0; shapedInstanceItr < maskedShapeInstanceList.length; shapedInstanceItr++) {
            maskedShapeInstanceList[shapedInstanceItr].mask = mask;
        }

        this.timeline.addTween(cjs.Tween.get(this.instance).to({ x: -198.75, y: 421.2 }, 499).wait(1));

        this._renderFirstFrame();

    }).prototype = p = new lib.AnMovieClip();
    p.nominalBounds = new cjs.Rectangle(565, 567, 490.29999999999995, 490.29999999999995);
    // library properties:
    lib.properties = {
        id: 'D3ABBD737DF5094980460F0B3F29EB51',
        width: 1080,
        height: 1080,
        fps: 15,
        color: "#000000",
        opacity: 0.00,
        manifest: [
            { src: "/assets/images/planets/neptune_atlas_1.png", id: "neptune_atlas_1" }
        ],
        preloads: []
    };



    // bootstrap callback support:

    (lib.Stage = function (canvas) {
        createjs.Stage.call(this, canvas);
    }).prototype = p = new createjs.Stage();

    p.setAutoPlay = function (autoPlay) {
        this.tickEnabled = autoPlay;
    }
    p.play = function () { this.tickEnabled = true; this.getChildAt(0).gotoAndPlay(this.getTimelinePosition()) }
    p.stop = function (ms) { if (ms) this.seek(ms); this.tickEnabled = false; }
    p.seek = function (ms) { this.tickEnabled = true; this.getChildAt(0).gotoAndStop(lib.properties.fps * ms / 1000); }
    p.getDuration = function () { return this.getChildAt(0).totalFrames / lib.properties.fps * 1000; }

    p.getTimelinePosition = function () { return this.getChildAt(0).currentFrame / lib.properties.fps * 1000; }

    an.bootcompsLoaded = an.bootcompsLoaded || [];
    if (!an.bootstrapListeners) {
        an.bootstrapListeners = [];
    }

    an.bootstrapCallback = function (fnCallback) {
        an.bootstrapListeners.push(fnCallback);
        if (an.bootcompsLoaded.length > 0) {
            for (var i = 0; i < an.bootcompsLoaded.length; ++i) {
                fnCallback(an.bootcompsLoaded[i]);
            }
        }
    };

    an.compositions = an.compositions || {};
    an.compositions['D3ABBD737DF5094980460F0B3F29EB51'] = {
        getStage: function () { return exportRoot.stage; },
        getLibrary: function () { return lib; },
        getSpriteSheet: function () { return ss; },
        getImages: function () { return img; }
    };

    an.compositionLoaded = function (id) {
        an.bootcompsLoaded.push(id);
        for (var j = 0; j < an.bootstrapListeners.length; j++) {
            an.bootstrapListeners[j](id);
        }
    }

    an.getComposition = function (id) {
        return an.compositions[id];
    }


    an.makeResponsive = function (isResp, respDim, isScale, scaleType, domContainers) {
        var lastW, lastH, lastS = 1;
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        function resizeCanvas() {
            var w = lib.properties.width, h = lib.properties.height;
            var iw = window.innerWidth, ih = window.innerHeight;
            var pRatio = window.devicePixelRatio || 1, xRatio = iw / w, yRatio = ih / h, sRatio = 1;
            if (isResp) {
                if ((respDim == 'width' && lastW == iw) || (respDim == 'height' && lastH == ih)) {
                    sRatio = lastS;
                }
                else if (!isScale) {
                    if (iw < w || ih < h)
                        sRatio = Math.min(xRatio, yRatio);
                }
                else if (scaleType == 1) {
                    sRatio = Math.min(xRatio, yRatio);
                }
                else if (scaleType == 2) {
                    sRatio = Math.max(xRatio, yRatio);
                }
            }
            domContainers[0].width = w * pRatio * sRatio;
            domContainers[0].height = h * pRatio * sRatio;
            domContainers.forEach(function (container) {
                // container.style.width = w * sRatio + 'px';				
                // container.style.height = h * sRatio + 'px';			
            });
            stage.scaleX = pRatio * sRatio;
            stage.scaleY = pRatio * sRatio;
            lastW = iw; lastH = ih; lastS = sRatio;
            stage.tickOnUpdate = false;
            stage.update();
            stage.tickOnUpdate = true;
        }
    }
    an.handleSoundStreamOnTick = function (event) {
        if (!event.paused) {
            var stageChild = stage.getChildAt(0);
            if (!stageChild.paused || stageChild.ignorePause) {
                stageChild.syncStreamSounds();
            }
        }
    }


})(createjs = createjs || {}, AdobeAn = AdobeAn || {});
var createjs, AdobeAn;
// ! ============================= PLANETS
var canvas, canvas2, canvas3, canvas4, canvas5, canvas6, stage, exportRoot, anim_container, dom_overlay_container, fnStartAnimation;
function initPlanets() {

    canvas = document.getElementById("moonCanvas");
    canvas2 = document.getElementById('marsCanvas');
    canvas3 = document.getElementById('neptuneCanvas');
    canvas4 = document.getElementById('jupiterCanvas');
    canvas5 = document.getElementById('callistoCanvas');

    // moon
    var comp = AdobeAn.getComposition("A3AB6E8092563F44A2D2FE775D5778E1");
    // mars
    var comp2 = AdobeAn.getComposition("D7E3423B551E00458CD72DB4C211F4E1");
    // neptune
    var comp3 = AdobeAn.getComposition('D3ABBD737DF5094980460F0B3F29EB51');
    // jupiter
    var comp4 = AdobeAn.getComposition('41345EC838562E4499D52D822F835ECC');
    // callisto
    var comp5 = AdobeAn.getComposition('1502B00D1E71F64390F1196A3331296B');

    // moon
    var lib = comp.getLibrary();
    // mars
    var lib2 = comp2.getLibrary();
    // neptune
    var lib3 = comp3.getLibrary();
    // jupiter
    var lib4 = comp4.getLibrary();
    // callisto
    var lib5 = comp5.getLibrary();

    //moon
    var loader = new createjs.LoadQueue(false);
    // mars
    var loader2 = new createjs.LoadQueue(false);
    // neptune
    var loader3 = new createjs.LoadQueue(false);
    // jupiter
    var loader4 = new createjs.LoadQueue(false);
    // callisto
    var loader5 = new createjs.LoadQueue(false);

    if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        // moon
        loader.addEventListener("fileload", function (evt) { handleMoonFileLoad(evt, comp) });
        loader.addEventListener("complete", function (evt) { handleMoonComplete(evt, comp) });
        // mars
        loader2.addEventListener("fileload", function (evt) { handleMarsFileLoad(evt, comp2) });
        loader2.addEventListener("complete", function (evt) { handleMarsComplete(evt, comp2) });
        // neptune
        loader3.addEventListener("fileload", function (evt) { handleNeptuneFileLoad(evt, comp3) });
        loader3.addEventListener("complete", function (evt) { handleNeptuneComplete(evt, comp3) });
        // jupiter
        loader4.addEventListener("fileload", function (evt) { handleJupiterFileLoad(evt, comp4) });
        loader4.addEventListener("complete", function (evt) { handleJupiterComplete(evt, comp4) });
        // callisto
        loader5.addEventListener("fileload", function (evt) { handleCallistoFileLoad(evt, comp5) });
        loader5.addEventListener("complete", function (evt) { handleCallistoComplete(evt, comp5) });
    } else {
        canvas6 = document.getElementById('mobileCanvas');
        let comp6 = AdobeAn.getComposition('D7E3423B551E00458CD72DB4C211F4E1');
        var lib6 = comp6.getLibrary();
        let loader6 = new createjs.LoadQueue(false);
        // mars
        loader6.addEventListener("fileload", function (evt) { handleMobileFileLoad(evt, comp2) });
        loader6.addEventListener("complete", function (evt) { handleMobileCanvasComplete(evt, comp2) });
        var lib6 = comp6.getLibrary();
        loader6.loadManifest(lib6.properties.manifest);
    }

    // moon
    var lib = comp.getLibrary();
    // mars
    var lib2 = comp2.getLibrary();
    // neptune
    var lib3 = comp3.getLibrary();
    // jupiter
    var lib4 = comp4.getLibrary();
    // callisto
    var lib5 = comp5.getLibrary();

    // moon
    loader.loadManifest(lib.properties.manifest);
    // mars
    loader2.loadManifest(lib2.properties.manifest);
    // neptune
    loader3.loadManifest(lib3.properties.manifest);
    // jupiter
    loader4.loadManifest(lib4.properties.manifest);
    // callisto
    loader5.loadManifest(lib5.properties.manifest);
}

// ! MOON
function handleMoonFileLoad(evt, comp) {
    var images = comp.getImages();
    if (evt && (evt.item.type == "image")) { images[evt.item.id] = evt.result; }
}
function handleMoonComplete(evt, comp) {
    //This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
    var lib = comp.getLibrary();
    var ss = comp.getSpriteSheet();
    var queue = evt.target;
    var ssMetadata = lib.ssMetadata;
    for (i = 0; i < ssMetadata.length; i++) {
        ss[ssMetadata[i].name] = new createjs.SpriteSheet({ "images": [queue.getResult(ssMetadata[i].name)], "frames": ssMetadata[i].frames });
    }

    exportRoot = new lib.savedAnMoon_HTML5Canvas();
    stage = new lib.Stage(canvas);
    //Registers the "tick" event listener.
    fnStartAnimation = function () {
        stage.addChild(exportRoot);
        createjs.Ticker.framerate = lib.properties.fps;
        createjs.Ticker.addEventListener("tick", stage);
    }
    //Code to support hidpi screens and responsive scaling.
    AdobeAn.makeResponsive(false, 'both', false, 1, [canvas, anim_container, dom_overlay_container]);
    AdobeAn.compositionLoaded(lib.properties.id);
    fnStartAnimation();
}
// ! MARS
function handleMarsFileLoad(evt, comp2) {
    var images = comp2.getImages();
    if (evt && (evt.item.type == "image")) { images[evt.item.id] = evt.result; }
}
function handleMarsComplete(evt, comp2) {
    //This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
    var lib = comp2.getLibrary();
    var ss = comp2.getSpriteSheet();
    var queue = evt.target;
    var ssMetadata = lib.ssMetadata;
    for (i = 0; i < ssMetadata.length; i++) {
        ss[ssMetadata[i].name] = new createjs.SpriteSheet({ "images": [queue.getResult(ssMetadata[i].name)], "frames": ssMetadata[i].frames })
    }
    exportRoot = new lib.savedAnMars_HTML5Canvas();
    stage = new lib.Stage(canvas2);
    //Registers the "tick" event listener.
    fnStartAnimation = function () {
        stage.addChild(exportRoot);
        createjs.Ticker.framerate = lib.properties.fps;
        createjs.Ticker.addEventListener("tick", stage);
    }
    //Code to support hidpi screens and responsive scaling.
    AdobeAn.makeResponsive(false, 'both', false, 1, [canvas2, anim_container, dom_overlay_container]);
    AdobeAn.compositionLoaded(lib.properties.id);
    fnStartAnimation();
}
// ! NEPTUNE
function handleNeptuneFileLoad(evt, comp3) {
    var images = comp3.getImages();
    if (evt && (evt.item.type == "image")) { images[evt.item.id] = evt.result; }
}

function handleNeptuneComplete(evt, comp3) {
    //This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
    var lib = comp3.getLibrary();
    var ss = comp3.getSpriteSheet();
    var queue = evt.target;
    var ssMetadata = lib.ssMetadata;
    for (i = 0; i < ssMetadata.length; i++) {
        ss[ssMetadata[i].name] = new createjs.SpriteSheet({ "images": [queue.getResult(ssMetadata[i].name)], "frames": ssMetadata[i].frames })
    }
    exportRoot = new lib.savedAnNeptune_HTML5Canvas();
    stage = new lib.Stage(canvas3);
    //Registers the "tick" event listener.
    fnStartAnimation = function () {
        stage.addChild(exportRoot);
        createjs.Ticker.framerate = lib.properties.fps;
        createjs.Ticker.addEventListener("tick", stage);
    }
    //Code to support hidpi screens and responsive scaling.
    AdobeAn.makeResponsive(false, 'both', false, 1, [canvas3, anim_container, dom_overlay_container]);
    AdobeAn.compositionLoaded(lib.properties.id);
    fnStartAnimation();
}

// ! JUPITER

function handleJupiterFileLoad(evt, comp4) {
    var images = comp4.getImages();
    if (evt && (evt.item.type == "image")) { images[evt.item.id] = evt.result; }
}

function handleJupiterComplete(evt, comp4) {
    //This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
    var lib = comp4.getLibrary();
    var ss = comp4.getSpriteSheet();
    var queue = evt.target;
    var ssMetadata = lib.ssMetadata;
    for (i = 0; i < ssMetadata.length; i++) {
        ss[ssMetadata[i].name] = new createjs.SpriteSheet({ "images": [queue.getResult(ssMetadata[i].name)], "frames": ssMetadata[i].frames })
    }
    exportRoot = new lib.savedAnJupiter_HTML5Canvas();
    stage = new lib.Stage(canvas4);
    //Registers the "tick" event listener.
    fnStartAnimation = function () {
        stage.addChild(exportRoot);
        createjs.Ticker.framerate = lib.properties.fps;
        createjs.Ticker.addEventListener("tick", stage);
    }
    //Code to support hidpi screens and responsive scaling.
    AdobeAn.makeResponsive(false, 'both', false, 1, [canvas4, anim_container, dom_overlay_container]);
    AdobeAn.compositionLoaded(lib.properties.id);
    fnStartAnimation();
}

// ! CALLISTO

function handleCallistoFileLoad(evt, comp5) {
    var images = comp5.getImages();
    if (evt && (evt.item.type == "image")) { images[evt.item.id] = evt.result; }
}

function handleCallistoComplete(evt, comp5) {
    //This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
    var lib = comp5.getLibrary();
    var ss = comp5.getSpriteSheet();
    var queue = evt.target;
    var ssMetadata = lib.ssMetadata;
    for (i = 0; i < ssMetadata.length; i++) {
        ss[ssMetadata[i].name] = new createjs.SpriteSheet({ "images": [queue.getResult(ssMetadata[i].name)], "frames": ssMetadata[i].frames })
    }
    exportRoot = new lib.savedAnCallisto_HTML5Canvas();
    stage = new lib.Stage(canvas5);
    //Registers the "tick" event listener.
    fnStartAnimation = function () {
        stage.addChild(exportRoot);
        createjs.Ticker.framerate = lib.properties.fps;
        createjs.Ticker.addEventListener("tick", stage);
    }
    //Code to support hidpi screens and responsive scaling.
    AdobeAn.makeResponsive(false, 'both', false, 1, [canvas5, anim_container, dom_overlay_container]);
    AdobeAn.compositionLoaded(lib.properties.id);
    fnStartAnimation();
}

// ! MOBILE CANVAS
function handleMobileFileLoad(evt, comp6) {
    var images = comp6.getImages();
    if (evt && (evt.item.type == "image")) { images[evt.item.id] = evt.result; }
}

function handleMobileCanvasComplete(evt, comp6) {
    //This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
    var lib = comp6.getLibrary();
    var ss = comp6.getSpriteSheet();
    var queue = evt.target;
    var ssMetadata = lib.ssMetadata;
    for (i = 0; i < ssMetadata.length; i++) {
        ss[ssMetadata[i].name] = new createjs.SpriteSheet({ "images": [queue.getResult(ssMetadata[i].name)], "frames": ssMetadata[i].frames })
    }
    exportRoot = new lib.savedAnMars_HTML5Canvas();
    stage = new lib.Stage(canvas6);
    //Registers the "tick" event listener.
    fnStartAnimation = function () {
        stage.addChild(exportRoot);
        createjs.Ticker.framerate = lib.properties.fps;
        createjs.Ticker.addEventListener("tick", stage);
    }
    //Code to support hidpi screens and responsive scaling.
    AdobeAn.makeResponsive(false, 'both', false, 1, [canvas6, anim_container, dom_overlay_container]);
    AdobeAn.compositionLoaded(lib.properties.id);
    fnStartAnimation();
}
// ! ======================================================== SPECIALTIES
$(window).on('load', function () {
    let hasReached = false;
    $(window).on('scroll', function () {
        let windowBottom = $(this).scrollTop() + $(this).innerHeight();
        $('#specialtiesTitle').each(function () {
            /* Check the location of each desired element */
            let objectBottom = $(this).offset().top + $(this).outerHeight();
            /* If the element is completely within bounds of the window, fade it in */
            if (objectBottom < windowBottom - 100 && !hasReached) {
                // image.style.display = 'block';
                // initSpecialtyContent();
                let p = document.getElementById('specialtiesTitle');
                p.innerHTML = '';
                let n = 0;
                let str = 'Specialties & Experience';
                let typeSpecialty = setInterval(function () {
                    n = n + 1;
                    p.innerHTML = str.slice(0, n) + ' <span style="color: #c75000; font-size: 2.2rem;">|</span>';
                    if (n === str.length) {
                        clearInterval(typeSpecialty);
                        p.innerHTML = str;
                        n = 0;
                        setInterval(function () {

                            if (n === 0) {
                                p.innerHTML = str + ' <span style="color: #c75000; font-size: 2.2rem;">|</span>';
                                n = 1;
                            } else {
                                p.innerHTML = str + '<span style="color: transparent; font-size: 2.2rem;">|</span>';
                                n = 0;
                            };
                        }, 500);
                    };
                }, 40)
                hasReached = true;
            }
        });
    });
    //    3d canvas
    TagCanvas.Start('myCanvas', 'tags', {
        textColour: 'white',
        outlineColour: 'transparent',
        bgOutlineThickness: 0,
        reverse: true,
        depth: 0.05,
        decel: .98,
        maxSpeed: 0.04,
        initial: [0.1, -0.1],
        pinchZoom: true,
        zoomMax: 1,
        shuffleTags: true,
        zoom: .85
    });
});
// ! ================================================================= GAME
(function () {
    'use strict';

    // General
    let canvas,
        screen,
        gameSize,
        game;

    // Assets
    let invaderCanvas,
        invaderMultiplier,
        //   size of enemies 
        invaderSize = 20,
        playerCanvas,
        // player image size
        playerSize = 20,
        // initialOffsetInvader,
        invaderAttackRate,
        // how large of a jump in pixels per invader movement
        invaderSpeed,
        // how fast the time interval takes for each movement
        // invaderRefreshRate = 10,
        //   the delay for when you finish a level. how long it comes back with new enemies 
        invaderSpawnDelay = 1;

    // Counter
    let i = 0,
        gameLevel = 0,
        kills = 0,
        spawnDelayCounter = invaderSpawnDelay;

    let invaderDownTimer;

    // blocks for random layout
    let blocks = [];

    // Game Controller
    let Game = function () {
        this.lost = false;
        this.player = new Player();
        this.invaders = [];
        this.invaderShots = [];

        // initiate the invaders to move and changes the amount of time per step moved
        if (invaderDownTimer === undefined) {
            invaderDownTimer = setInterval(function () {
                for (i = 0; i < game.invaders.length; i++) game.invaders[i].move();
            }, 0);
        };
    }

    Game.prototype = {
        // for when the user completes a level
        update: function () {

            // Next level when all invaders die
            if (game.invaders.length === 0) {

                spawnDelayCounter += 1;
                if (spawnDelayCounter < invaderSpawnDelay) return;

                // for when all invaders die. change the level amount
                gameLevel += 1;
                if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) { 
                    if (gameLevel === 1) {
                        // how often the invaders shoot
                        invaderAttackRate -= 0.001;
                    } else if (gameLevel === 2) {
                        // how often the invaders shoot
                        invaderAttackRate -= 0.008;
                        // add new section of invaders
                        blocks.unshift([3.5, 10.5]);
                        // up the speed of the invaders
                        invaderSpeed += .5;
                    } else if (gameLevel === 3) {
                        // add new section of invaders
                        blocks.unshift([0, 7, 14]);
                    } else if (gameLevel === 4) {
                        // add new section of invaders
                        blocks.unshift([3.5, 10.5]);
                    } else if (gameLevel === 5) {
                        // add new section of invaders
                        blocks.unshift([0, 7, 14]);
                        // add new section of invaders
                        blocks.unshift([0, 7, 14]);
                        // add new section of invaders
                        blocks.unshift([3.5, 10.5]);
                    } else if (gameLevel === 6) {
                        // up the speed of the invaders
                        invaderSpeed += .5;
                        // how often the invaders shoot
                        invaderAttackRate -= 0.01;
                    } else {
                        // add new section of invaders
                        blocks.unshift([3.5, 10.5]);
                        // add new section of invaders
                        blocks.unshift([0, 7, 14]);
                    }
                } else {
                    if (gameLevel === 1) {
                        // how often the invaders shoot
                        invaderAttackRate -= 0.001;
                    } else if (gameLevel === 2) {
                        // how often the invaders shoot
                        // invaderAttackRate -= 0.008;
                        // add new section of invaders
                        blocks.unshift([2, 4]);
                        // up the speed of the invaders
                        // invaderSpeed += .5;
                    } else if (gameLevel === 3) {
                        // add new section of invaders
                        blocks.unshift([0, 3, 6]);
                    } else if (gameLevel === 4) {
                        // add new section of invaders
                        blocks.unshift([2, 4]);
                    } else if (gameLevel === 5) {
                        // add new section of invaders
                        blocks.unshift([0, 3, 6]);
                        // add new section of invaders
                        blocks.unshift([2, 4]);
                    } else if (gameLevel === 6) {
                        // up the speed of the invaders
                        // invaderSpeed += .5;
                        // how often the invaders shoot
                        invaderAttackRate -= 0.01;
                    } else {
                        // add new section of invaders
                        blocks.unshift([2, 4]);
                    }
                }

                game.invaders = createInvaders();

                spawnDelayCounter = 0;
            }

            if (!this.lost) {

                // Collision for when the projectile hits an invader
                game.player.projectile.forEach(function (projectile) {
                    game.invaders.forEach(function (invader) {
                        if (collides(projectile, invader)) {
                            invader.destroy();
                            projectile.active = false;
                        }
                    });
                });
                // for if a projectile hits the user player
                this.invaderShots.forEach(function (invaderShots) {
                    if (collides(invaderShots, game.player)) {
                        game.player.destroy();
                    }
                });
                for (i = 0; i < game.invaders.length; i++) game.invaders[i].update();
            }

            // Don't stop player & projectiles.
            game.player.update();
            for (i = 0; i < game.invaderShots.length; i++) game.invaderShots[i].update();

            this.invaders = game.invaders.filter(function (invader) {
                return invader.active;
            });

        },

        // draw on the canvas
        draw: function () {
            if (this.lost) {
                // assigning total points into a variable
                const totalPoints = kills * 6;
                const prevPoints = localStorage.getItem('points');
                const prevLevel = localStorage.getItem('level');
                const prevKills = localStorage.getItem('kills');
                const highScoreRender = document.getElementById('highScoreMessage');
                // for if a user gets a high score change this so a message can be displayed on the canvas
                let hasHighScore = false;
                // changes layer filter of canvas
                screen.fillStyle = 'rgba(0, 0, 0, 0.01)';
                screen.fillRect(0, 0, gameSize.width, gameSize.height);

                if (totalPoints > prevPoints) {
                    localStorage.setItem('points', totalPoints);
                    hasHighScore = true;
                }

                if (gameLevel > prevLevel) {
                    localStorage.setItem('level', gameLevel);
                    hasHighScore = true;
                }

                if (kills > prevKills) {
                    localStorage.setItem('kills', kills);
                    hasHighScore = true;
                }

                screen.textAlign = 'center';
                // changes the color of the text and projectiles
                screen.fillStyle = '#c75000';
                // if there is a high score render the text
                if (hasHighScore) {
                    highScoreRender.style.display = 'block';
                    highScoreRender.innerHTML = 'YOU GOT A HIGH SCORE!';
                }
                screen.font = '2rem Mandatory Plaything';
                screen.fillText('YOU DIED', gameSize.width / 2, gameSize.height / 2 - 20);
                screen.font = '1.2rem Mandatory Plaything';
                screen.fillText('TOTAL KILLS: ' + kills, gameSize.width / 2, gameSize.height / 2 + 20);
                screen.font = '1.2rem Mandatory Plaything';
                screen.fillText('POINTS: ' + totalPoints, gameSize.width / 2, gameSize.height / 2 + 50);
                screen.font = '1rem Mandatory Plaything';
                screen.fillText('LEVEL: ' + gameLevel, gameSize.width / 2, gameSize.height / 2 + 80);
                // rendering the restart button
                document.getElementById('restartBtn').style.display = 'block';

            } else {
                // text elements
                const killEl = document.getElementById('kills');
                const levelEl = document.getElementById('level');
                const pointEl = document.getElementById('points');
                // need to clearRect or game breaks 
                screen.clearRect(0, 0, gameSize.width, gameSize.height);

                // bottom right of canvas showing kills,level,points
                killEl.innerHTML = `KILLS: ${kills}`;
                levelEl.innerHTML = `LEVEL: ${gameLevel}`;
                pointEl.innerHTML = `POINTS: ${kills * 6}`;
            }

            screen.beginPath();

            let i;
            this.player.draw();
            if (!this.lost) {
                for (i = 0; i < this.invaders.length; i++) this.invaders[i].draw();
                for (i = 0; i < this.invaderShots.length; i++) this.invaderShots[i].draw();
            }
            screen.fill();
        },

        // checks if the invaders are below the canvas size. if so they wont shoot
        invadersBelow: function (invader) {
            return this.invaders.filter(function (b) {
                return Math.abs(invader.coordinates.x - b.coordinates.x) === 0 &&
                    b.coordinates.y > invader.coordinates.y;
            }).length > 0;
        }
    };

    // ! INVADERS
    let Invader = function (coordinates) {
        this.active = true;
        this.coordinates = coordinates;
        this.size = {
            width: invaderSize,
            height: invaderSize
        };
        this.patrolX = 0;
        this.speedX = invaderSpeed;
    };

    Invader.prototype = {
        update: function () {
            // invader projectiles
            if (Math.random() > invaderAttackRate && !game.invadersBelow(this)) {
                // speed and coordinates of enemy projectiles
                let projectile = new Projectile({
                    x: this.coordinates.x + this.size.width / 2,
                    y: this.coordinates.y + this.size.height - 5
                }, {
                    x: 0,
                    y: 1
                });
                game.invaderShots.push(projectile);
            }

        },
        draw: function () {
            if (this.active) screen.drawImage(invaderCanvas, this.coordinates.x, this.coordinates.y);
        },
        move: function () {
            // if statement dictates how far the invaders will travel from left to right
            if (this.patrolX < 0 || this.patrolX > gameSize.width / 2) {
                this.speedX = -this.speedX;
                // ? once invaders reach the right side they go strait down 
                this.patrolX += this.speedX;
                // how far invaders move forward
                this.coordinates.y += 10;

                // if the invaders reach the end of the canvas. end game
                if (this.coordinates.y + this.size.height * 2 > gameSize.height) game.lost = true;
            } else {
                // for how long till the invaders move forward
                this.coordinates.x += this.speedX;
                this.patrolX += this.speedX;
            }
        },
        destroy: function () {
            this.active = false;
            // add to kills if an invader dies
            kills += 1;
        }
    };

    // Player
    let Player = function () {
        this.active = true;
        this.size = {
            width: playerSize,
            height: playerSize
        };
        // how many bullets burst out at ones when game starts
        this.shooterHeat = -3;

        // where the player starts on start game
        this.coordinates = {
            x: gameSize.width / 2 - (this.size.width / 2) | 0,
            y: gameSize.height - this.size.height * 2
        };

        this.projectile = [];
        this.keyboarder = new KeyController();
    };

    Player.prototype = {
        update: function () {
            for (let i = 0; i < this.projectile.length; i++) {
                this.projectile[i].update();
            }

            this.projectile = this.projectile.filter(function (projectile) {
                return projectile.active;
            });

            if (!this.active) return;

            // buttons for mobile 
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                const leftBtn = document.getElementById('leftBtn');
                const rightBtn = document.getElementById('rightBtn');

                leftBtn.onmousedown = () => {
                    this.coordinates.x -= 3;
                }
                rightBtn.onmousedown = () => {
                    this.coordinates.x += 3;
                }
            }
            // controls the left and right speed of player
            if (this.keyboarder.isDown(this.keyboarder.KEYS.LEFT) && this.coordinates.x > 0) {
                this.coordinates.x -= 3;
            }
            else if (this.keyboarder.isDown(this.keyboarder.KEYS.RIGHT) && this.coordinates.x < gameSize.width - this.size.width) {
                this.coordinates.x += 3;
            }
            // ! AUTO SHOOT IS TURNED ON
            // check if on mobile or not. if so turn on full auto!
            // if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            // how fast the player can shoot
            this.shooterHeat += 1.5;
            if (this.shooterHeat < 0) {
                // creating a new projectile and adjusting the coordinates/speed
                let projectile = new Projectile({
                    x: this.coordinates.x + this.size.width / 2 - 1,
                    y: this.coordinates.y - 1
                }, {
                    x: 0,
                    y: -7
                });
                this.projectile.push(projectile);
            } else if (this.shooterHeat > 12) {
                // how many shoot out after each shot
                this.shooterHeat = -2;
            }
            // return;
            // }

            // ! FOR SPACE BAR SHOOT
            // for if the player is shooting
            // if (this.keyboarder.isDown(this.keyboarder.KEYS.Space)) {
            //     // how fast the player can shoot
            //     this.shooterHeat += 1;
            //     if (this.shooterHeat < 0) {
            //         // creating a new projectile and adjusting the coordinates/speed
            //         let projectile = new Projectile({
            //             x: this.coordinates.x + this.size.width / 2 - 1,
            //             y: this.coordinates.y - 1
            //         }, {
            //             x: 0,
            //             y: -7
            //         });
            //         this.projectile.push(projectile);
            //     } else if (this.shooterHeat > 12) {
            //         this.shooterHeat = -3;
            //     }
            // } else {
            //     this.shooterHeat = -3;
            // }
        },
        // draw the ship
        draw: function () {
            if (this.active) {
                screen.drawImage(playerCanvas, this.coordinates.x, this.coordinates.y);
            }

            for (let i = 0; i < this.projectile.length; i++) {
                this.projectile[i].draw();
            }

        },
        // destroy and lose the game
        destroy: function () {
            this.active = false;
            game.lost = true;
        }
    };

    // Projectile
    let Projectile = function (coordinates, velocity) {
        this.active = true;
        this.coordinates = coordinates;
        // size of each projectile
        this.size = {
            width: 2,
            height: 6
        };
        // speed of projectiles
        this.velocity = velocity;
    };

    Projectile.prototype = {
        update: function () {
            this.coordinates.x += this.velocity.x;
            this.coordinates.y += this.velocity.y;

            if (this.coordinates.y > gameSize.height || this.coordinates.y < 0) {
                this.active = false;
            }

        },
        draw: function () {
            if (this.active) {
                screen.rect(this.coordinates.x, this.coordinates.y, this.size.width, this.size.height);
                // color of the projectiles
                screen.fillStyle = '#48ff00';
            }
        }
    };
    // Keyboard input tracking
    let KeyController = function () {
        this.KEYS = {
            LEFT: 37,
            RIGHT: 39,
            Space: 32
        };
        let keyCode = [37, 39, 32];
        let keyState = {};

        let counter;
        window.addEventListener('keydown', function (e) {
            for (counter = 0; counter < keyCode.length; counter++)
                if (keyCode[counter] == e.keyCode) {
                    keyState[e.keyCode] = true;
                    e.preventDefault();
                }

        });

        window.addEventListener('keyup', function (e) {
            for (counter = 0; counter < keyCode.length; counter++)
                if (keyCode[counter] == e.keyCode) {
                    keyState[e.keyCode] = false;
                    e.preventDefault();
                }
        });

        this.isDown = function (keyCode) {
            return keyState[keyCode] === true;
        };

    };

    // checking if the arguments a & b collide
    function collides(a, b) {
        return a.coordinates.x < b.coordinates.x + b.size.width &&
            a.coordinates.x + a.size.width > b.coordinates.x &&
            a.coordinates.y < b.coordinates.y + b.size.height &&
            a.coordinates.y + a.size.height > b.coordinates.y;
    };

    // get location of pixels where invaders are starting up at
    function getPixelRow(rowRaw) {
        let textRow = [],
            placer = 0,
            row = Math.floor(rowRaw / invaderMultiplier);
        if (row >= blocks.length) return [];
        for (let i = 0; i < blocks[row].length; i++) {
            let tmpContent = blocks[row][i] * invaderMultiplier;
            for (let j = 0; j < invaderMultiplier; j++) textRow[placer + j] = tmpContent + j;
            placer += invaderMultiplier;
        }
        return textRow;
    }

    // create the invaders and locations
    function createInvaders() {
        let invaders = [];
        let i = blocks.length * invaderMultiplier;
        while (i--) {
            let j = getPixelRow(i);
            for (let k = 0; k < j.length; k++) {
                // renders how far spread the invaders are together
                invaders.push(new Invader({
                    x: j[k] * invaderSize,
                    y: i * invaderSize
                }));
            }
        }
        return invaders;
    }

    // Start game
    document.getElementById('startBtn').onclick = () => {
        let invaderAsset = new Image();
        let playerAsset = new Image();

        invaderAsset.onload = function () {
            // draw the invaders
            invaderCanvas = document.createElement('canvas');
            invaderCanvas.width = invaderSize;
            invaderCanvas.height = invaderSize;
            invaderCanvas.getContext("2d").drawImage(invaderAsset, 0, 0);
        };
        // on player load, draw player & initiate the game
        playerAsset.onload = () => {
            // draw the player
            playerCanvas = document.createElement('canvas');
            playerCanvas.width = playerSize;
            playerCanvas.height = playerSize;
            playerCanvas.getContext('2d').drawImage(playerAsset, 0, 0);

            initGameData();
            loop();
        };
        // image assets for player and invaders
        invaderAsset.src = './assets/images/game/invaderShip.png';
        playerAsset.src = './assets/images/game/invaderSm.png';
    };

    // on load event
    window.addEventListener('load', () => {
        // create the canvas
        canvas = document.getElementById('space-invaders');
        screen = canvas.getContext('2d');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');

        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            leftBtn.style.display = 'block';
            rightBtn.style.display = 'block';
        } else {
            leftBtn.style.display = 'none';
            rightBtn.style.display = 'none';
        }
        // configure the size
        configSize();
    });

    window.addEventListener('resize', () => {
        // when window size is changed, change the size of the canvas
        configSize();
    });

    // configure the size of the canvas
    const configSize = () => {
        // the outer div surrounding the canvas
        const wrapper = document.getElementById('gameWrap');
        // create the canvas size
        if (window.innerWidth > 1200) {
            screen.canvas.width = 1200;
            screen.canvas.height = 700;
            wrapper.style.width = '1200px';
            wrapper.style.height = '700px';
            // setting the game screen size
            gameSize = {
                width: 1200,
                height: 700
            };
            // how many invaders group together
            invaderMultiplier = 2;
            // initialOffsetInvader = 1600;
        } else if (window.innerWidth > 920) {
            screen.canvas.width = 900;
            screen.canvas.height = 600;
            wrapper.style.width = '900px';
            wrapper.style.height = '600px';
            gameSize = {
                width: 900,
                height: 600
            };
            invaderMultiplier = 2;
            // initialOffsetInvader = 280;
        } else if (window.innerWidth > 736) {
            screen.canvas.width = 700;
            screen.canvas.height = 500;
            wrapper.style.width = '700px';
            wrapper.style.height = '500px';

            gameSize = {
                width: 700,
                height: 500
            };
            invaderMultiplier = 1;
        } else if (window.innerWidth > 518) {
            screen.canvas.width = 500;
            screen.canvas.height = 500;
            wrapper.style.width = '500px';
            wrapper.style.height = '500px';

            gameSize = {
                width: 500,
                height: 500
            };
            invaderMultiplier = 1;
        } else if (window.innerWidth > 430) {
            screen.canvas.width = 400;
            screen.canvas.height = 500;
            wrapper.style.width = '400px';
            wrapper.style.height = '500px';

            gameSize = {
                width: 400,
                height: 400
            };
            invaderMultiplier = 1;
        } else {
            screen.canvas.width = 300;
            screen.canvas.height = 500;
            wrapper.style.width = '300px';
            wrapper.style.height = '500px';

            gameSize = {
                width: 300,
                height: 500
            };
            invaderMultiplier = 1;
        }
    }

    // initiate beginning game data
    function initGameData() {
        configSize();
        // starting kills back to 0
        kills = 0;
        // how often invaders shoot. (.1 being the most) - (.99999 being the least)
        invaderAttackRate = .9998;
        invaderSpeed = 1;
        // how long till the invaders spawn
        spawnDelayCounter = invaderSpawnDelay;
        // start the new game
        startGame();
    };

    // start a new game
    const startGame = () => {
        // set display to none to remove the restart button from screen
        document.getElementById('restartBtn').style.display = 'none';
        document.getElementById('startBtn').style.display = 'none';
        document.getElementById('highScoreMessage').style.display = 'none';
        if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            blocks = [
                [0, 7, 14],
            ];
        } else {
            blocks = [
                [0, 3, 6]
            ];
        }
        game = new Game();
    };

    // restart game
    document.getElementById('restartBtn').onclick = () => {
        // reset game level to 1
        gameLevel = 0;

        let invaderAsset = new Image();
        let playerAsset = new Image();

        invaderAsset.onload = function () {
            // draw the invaders
            invaderCanvas = document.createElement('canvas');
            invaderCanvas.width = invaderSize;
            invaderCanvas.height = invaderSize;
            invaderCanvas.getContext("2d").drawImage(invaderAsset, 0, 0);
        };
        // on player load, draw player & initiate the game
        playerAsset.onload = () => {
            // draw the player
            playerCanvas = document.createElement('canvas');
            playerCanvas.width = playerSize;
            playerCanvas.height = playerSize;
            playerCanvas.getContext('2d').drawImage(playerAsset, 0, 0);
            // Game Creation
            canvas = document.getElementById("space-invaders");
            screen = canvas.getContext('2d');

            initGameData();
        };
        // image assets for player and invaders
        invaderAsset.src = './assets/images/game/invaderShip.png';
        playerAsset.src = './assets/images/game/invaderSm.png';
    };

    // start looping through all the data and functions and initiate the animations
    function loop() {
        game.update();
        game.draw();
        requestAnimationFrame(loop);
    };
})();